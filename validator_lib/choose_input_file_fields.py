"""
Class to create a screen listing every file in the input folder with potential fields as fill in boxes or checkboxes.
Records the user's choices to the config file as defined in the ValidatorData class.
"""

import tkinter as tk
import tkinter.ttk as ttk
import tkinter.messagebox
import re

from validator_lib.validator_config import ValidatorConfig


class InputFieldsChooser:
    def __init__(self, input_files):
        self.validator_config = ValidatorConfig()
        self.window = None
        self.fields = None
        self.all_input_files = input_files
        self.warnings = None
        self.marc_cats = ["oclc", "583", "bib_id", "holdings_id", "863", "866", "holdings_1", "holdings_2"]
        self.spreadsheet_cats = ["header", "oclc", "bib_id", "holdings_id", "institution", "oclc_symbol", "location", 
                                 "issn", "title", "holdings_0", "holdings_1", "holdings_2", "holdings_3"]
        self.cat_labels = {
            "header": "Has header row",
            "oclc": "OCLC",
            "bib_id": "Bib no",
            "holdings_id": "Holdings ID",
            "issn": "ISSN",
            "title": "Title",
            "863": "Holdings in 863/864/865",
            "866": "Holdings in 866/867/868",
            "holdings_0": "Holdings field",
            "holdings_1": "Other holdings field",
            "holdings_2": "Other holdings field",
            "holdings_3": "Other holdings field",
            "institution": "Institution",
            "oclc_symbol": "OCLC symbol",
            "location": "Location",
            "583": "File has 583s"
        }
        self.checkbox_cats = {"header", "863", "866", "583"}
        self.spreadsheet_file_endings = [".txt", ".csv", ".tsv", ".xlsx", ".xls"]
        self.create_main_window()

    def create_main_window(self):
        """
        The main process.
        """
        self.warnings = []

        self.window = tk.Tk()
        self.window.title('Choose Input File Fields')
        window_width = 440
        window_height = 600
        self.window.geometry("{}x{}".format(window_width, window_height))

        canvas = tk.Canvas(self.window)
        scroll_y = ttk.Scrollbar(self.window, orient="vertical", command=canvas.yview)
        self.fields = {}

        instructions_text = 'Enter MARC fields/subfields like "001" or "904a".\n'
        instructions_text += 'Enter spreadsheet, tsv, or csv columns by number, starting with 1.\n'
        instructions_text += 'Leave unused fields blank.\n'
        instructions_text += 'Leave all fields blank to skip a title.\n'
        instructions_text += 'Click the reset button to clear all fields in all titles.'

        instructions_frame = tk.LabelFrame(self.window)
        instructions_label = tk.Label(self.window, text=instructions_text, justify=tk.LEFT, wraplength=400)
        instructions_label.pack()
        instructions_frame.pack()

        # spacer bar
        tk.Frame(self.window, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=5)

        f = tk.Frame(canvas)

        for input_file in self.all_input_files:
            if '_AUTOGENERATED_FILE' in input_file:
                continue

            tk.Label(f, text=input_file, font='Arial 10 bold').pack(anchor=tk.W)

            if input_file.endswith(".mrk"):
                self.fields[input_file] = self.get_file_fields(f, input_file, self.marc_cats)
            for file_ending in self.spreadsheet_file_endings:
                if input_file.endswith(file_ending):
                    self.fields[input_file] = self.get_file_fields(f, input_file, self.spreadsheet_cats)

            self.fields[input_file]["frame"].pack(anchor=tk.W, fill=tk.X, padx=5, pady=5)
            # spacer bar
            tk.Frame(f, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=5)

        btn_frame = tk.Frame(f)
        btn_save = tk.Button(btn_frame, text="Save", command=self.ok_clicked)
        btn_cancel = tk.Button(btn_frame, text="Cancel", command=self.cancelled)
        btn_reset = tk.Button(btn_frame, text="Reset Fields", command=self.reset_fields)
        btn_save.grid(column=0, row=0)
        btn_cancel.grid(column=1, row=0)
        btn_reset.grid(column=2, row=0)
        btn_frame.pack()

        canvas.create_window(0, 0, anchor="nw", window=f)
        canvas.update_idletasks()

        canvas.configure(scrollregion=canvas.bbox('all'), yscrollcommand=scroll_y.set)

        canvas.pack(fill='both', expand=True, side='left')
        scroll_y.pack(fill='y', side='right')

        # center the window on the screen
        ws = self.window.winfo_screenwidth()
        hs = self.window.winfo_screenheight()
        x = (ws / 2) - (window_width / 2)
        y = (hs / 2) - (window_height / 2)
        self.window.geometry('%dx%d+%d+%d' % (window_width, window_height, x, y))
        self.window.lift()

        self.window.mainloop()

    def get_file_fields(self, f, input_file, cats):
        """
        Fill in the relevant fields for a single input file, by looping through the provided input categories.
        """
        file_data = {"frame": tk.Frame(f)}
        row_number = 0
        for cat in cats:
            if cat in self.checkbox_cats:
                file_data["{}_{}".format(input_file, cat)] = tk.IntVar()
                file_data[cat] = tk.Checkbutton(file_data["frame"], text=self.cat_labels[cat],
                                                variable=file_data["{}_{}".format(input_file, cat)])
                self.pre_fill_entry(cat, input_file, file_data)
                file_data[cat].grid(row=row_number, column=0, columnspan=2, sticky=tk.W)
            else:
                tk.Label(file_data["frame"], text=self.cat_labels[cat]).grid(row=row_number, column=0, sticky=tk.W)
                file_data[cat] = tk.Entry(file_data["frame"], width=10)
                self.pre_fill_entry(cat, input_file, file_data)
                file_data[cat].grid(row=row_number, column=1)
                
            row_number += 1
        return file_data

    def pre_fill_entry(self, cat, input_file, file_data):
        """See if the input is in our config list, and insert preset values if so."""
        if input_file not in self.validator_config.config:
            return
        if cat not in self.validator_config.config[input_file]:
            return
        if cat in self.checkbox_cats:
            if self.validator_config.config[input_file][cat]:
                file_data["{}_{}".format(input_file, cat)].set(value=1)
        else:
            file_data[cat].insert(0, self.validator_config.config[input_file][cat])

    def basic_field_validation(self, input_file, field_name, field_to_check):
        if not field_to_check:
            return
        if len(field_to_check) < 3 or len(field_to_check) > 4:
            self.warnings.append("{}\n{} field {} is invalid length".format(input_file, field_to_check, field_name))
            return
        field = field_to_check[:3]
        field_int = ''
        if field.lower() != 'ldr':
            try:
                field_int = int(field)
            except ValueError:
                self.warnings.append("{}\n{} field {} is invalid field".format(input_file, field_to_check, field_name))
                return
        if field_int > 10 and len(field_to_check) == 3 and field_int != 35:
            self.warnings.append("{}\n{} field {} should have subfield".format(input_file, field_to_check, field_name))
        if len(field_to_check) == 4:
            subfield = field_to_check[3:]
            if not re.search(r"\w", subfield):
                self.warnings.append("{}\n{} field {} has invalid subfield".format(input_file, field_to_check,
                                                                                   field_name))

    def ok_clicked(self):
        """Record user choices to the config file."""
        for input_file in self.all_input_files:
            self.ok_clicked_get_file_data(input_file)

        if self.warnings:
            msg = ''
            response = tkinter.messagebox.showerror(title='ERROR', message="\n\n".join(self.warnings))
            self.cancelled()
            self.create_main_window()
        else:
            self.validator_config.write_validator_config_file()
            self.cancelled()

    def ok_clicked_get_file_data(self, input_file):
        possible_fields = ['{}_{}'.format(input_file, 'header'), '{}_583'.format(input_file), 'oclc', 'bib_id',
                           'holdings_id',
                           '{}_863'.format(input_file), '{}_866'.format(input_file), 'holdings_0', 'holdings_1',
                           'holdings_2', 'issn', 'title',  'institution', 'oclc_symbol', 'location', ]
        fields_to_validate = {'oclc', 'holdings_id', 'bib_id', 'holdings_1', 'holdings_2'}
        file_data = {}
        self.validator_config.config[input_file] = {}

        for possible_field in possible_fields:
            try:
                file_data[possible_field] = self.fields[input_file][possible_field].get()
            except KeyError:
                pass

        for possible_field in possible_fields:
            if possible_field not in file_data or not file_data[possible_field]:
                continue
            if input_file.endswith('.mrk') and possible_field in fields_to_validate:
                self.basic_field_validation(input_file, possible_field, file_data[possible_field])
            if '863' in possible_field:
                cat_name = '{}_863'.format(input_file)
                self.validator_config.config[input_file]['863'] = str(file_data[cat_name])
            elif '866' in possible_field:
                cat_name = '{}_866'.format(input_file)
                self.validator_config.config[input_file]['866'] = str(file_data[cat_name])
            elif '583' in possible_field:
                cat_name = '{}_583'.format(input_file)
                self.validator_config.config[input_file]['583'] = str(file_data[cat_name])
            elif 'header' in possible_field:
                cat_name = '{}_{}'.format(input_file, 'header')
                self.validator_config.config[input_file]['header'] = str(file_data[cat_name])
            else:
                self.validator_config.config[input_file][possible_field] = file_data[possible_field]

    def reset_fields(self):
        """
        This works by resetting the config file for all files, closing the window, then starting over.
        """
        segments = self.validator_config.config.keys()
        for segment in segments:
            if segment == 'Validator' or segment == 'DEFAULT':
                continue
            del self.validator_config.config[segment]
            self.validator_config.write_validator_config_file()
            self.validator_config.read_validator_config_file()
        self.cancelled()
        self.create_main_window()

    def cancelled(self):
        """Close without making any changes."""
        self.window.destroy()
