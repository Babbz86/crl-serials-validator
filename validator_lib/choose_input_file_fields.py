"""
Class to create a screen listing every file in the input folder with potential fields as fill in boxes or checkboxes.
Records the user's choices to the config file as defined in the ValidatorData class.
"""

import tkinter as tk
import tkinter.ttk as ttk
import tkinter.messagebox
import re

from validator_lib.validator_config import ValidatorConfig
from validator_lib.ttk_theme import set_ttk_style


class InputFields:
    marc_cats = ["oclc", "583", "bib_id", "holdings_id", "863", "866", "holdings_1", "holdings_2"]
    spreadsheet_cats = [
        "header", "oclc", "bib_id", "holdings_id", "institution", "oclc_symbol", "location", "issn", "title", 
        "holdings_0", "holdings_1", "holdings_2", "holdings_3"]
    cat_labels = {
            "header": "Has header row",
            "oclc": "OCLC",
            "bib_id": "Bib no",
            "holdings_id": "Holdings ID",
            "issn": "ISSN",
            "title": "Title",
            "863": "Holdings in 863/864/865",
            "866": "Holdings in 866/867/868",
            "holdings_0": "Holdings field",
            "holdings_1": "Other holdings field",
            "holdings_2": "Other holdings field",
            "holdings_3": "Other holdings field",
            "institution": "Institution",
            "oclc_symbol": "OCLC symbol",
            "location": "Location",
            "583": "File has 583s"
        }
    spreadsheet_file_endings = [".txt", ".csv", ".tsv", ".xlsx", ".xls"]


class InputFieldsChooser(tk.Tk):

    marc_instructions = 'Enter MARC fields/subfields like "001" or "904a".'
    spreadsheet_instructions = 'Enter columns by number, starting with 1.'

    def __init__(self, input_files):
        super().__init__()
        self.validator_config = ValidatorConfig()
        self.fields = None
        self.all_input_files = input_files
        self.warnings = None
        self.marc_cats = InputFields.marc_cats.copy()
        self.spreadsheet_cats = InputFields.spreadsheet_cats.copy()
        self.cat_labels = InputFields.cat_labels.copy()
        self.checkbox_cats = {"header", "863", "866", "583"}
        self.spreadsheet_file_endings = InputFields.spreadsheet_file_endings.copy()

        self.warnings = []

        style = set_ttk_style(self)

        self.title('Choose Input File Fields')
        window_width = 440
        window_height = 600
        self.geometry("{}x{}".format(window_width, window_height))

        canvas = tk.Canvas(self)
        scroll_y = ttk.Scrollbar(self, orient="vertical", command=canvas.yview)
        self.fields = {}

        instructions_text = 'Leave unused fields blank.\n'
        instructions_text += 'Leave all fields blank to skip a title.'

        # instructions_frame = ttk.LabelFrame(self)
        # instructions_label = ttk.Label(self, text=instructions_text, justify=tk.LEFT)
        # instructions_label.pack()
        # instructions_frame.pack(fill='x')

        # spacer bar
        tk.Frame(self, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=5)

        f = ttk.Frame(canvas)
        instructions_label = ttk.Label(f, text=instructions_text, justify=tk.LEFT)
        instructions_label.pack()

        tk.Frame(f, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=5)

        for input_file in self.all_input_files:
            if '_AUTOGENERATED_FILE' in input_file:
                continue

            ttk.Label(f, text=input_file, font='Arial 11 bold').pack(anchor=tk.W)

            if input_file.endswith(".mrk"):
                ttk.Label(f, text=self.marc_instructions, font='Arial 10', foreground='#111111').pack(anchor=tk.W)
                self.fields[input_file] = self.get_file_fields(f, input_file, self.marc_cats)
            for file_ending in self.spreadsheet_file_endings:
                if input_file.endswith(file_ending):
                    ttk.Label(f, text=self.spreadsheet_instructions, font='Arial 10', foreground='#111111').pack(anchor=tk.W)
                    self.fields[input_file] = self.get_file_fields(f, input_file, self.spreadsheet_cats)

            self.fields[input_file]["frame"].pack(anchor=tk.W, fill=tk.X, padx=5, pady=5)
            # spacer bar
            tk.Frame(f, height=2, bd=1, relief=tk.SUNKEN).pack(fill=tk.X, padx=5, pady=5)

        btn_frame = ttk.Frame(f)
        btn_save = ttk.Button(btn_frame, text="Save", command=self.ok_clicked)
        btn_save['style'] = 'success.TButton'
        btn_cancel = ttk.Button(btn_frame, text="Cancel", command=self.cancelled)
        btn_cancel['style'] = 'warning.TButton'
        btn_reset = ttk.Button(btn_frame, text="Reset Fields", command=self.reset_fields)
        btn_reset['style'] = 'danger.TButton'

        btn_save.grid(column=0, row=0)
        spacer1 = ttk.Label(btn_frame, text="")
        spacer1.grid(column=1, row=0)
        btn_cancel.grid(column=2, row=0)
        spacer2 = ttk.Label(btn_frame, text="")
        spacer2.grid(column=3, row=0)
        btn_reset.grid(column=4, row=0)
        btn_frame.pack()

        canvas.create_window(0, 0, anchor="nw", window=f)
        canvas.update_idletasks()

        canvas.configure(scrollregion=canvas.bbox('all'), yscrollcommand=scroll_y.set)

        canvas.pack(fill='both', expand=True, side='left')
        scroll_y.pack(fill='y', side='right')

        # center the window on the screen
        ws = self.winfo_screenwidth()
        hs = self.winfo_screenheight()
        x = (ws / 2) - (window_width / 2)
        y = (hs / 2) - (window_height / 2)
        # self.geometry('%dx%d+%d+%d' % (window_width, window_height, x, y))
        self.lift()

        self.mainloop()

    def get_file_fields(self, f, input_file, cats):
        """
        Fill in the relevant fields for a single input file, by looping through the provided input categories.
        """
        file_data = {"frame": ttk.Frame(f)}
        row_number = 0
        for cat in cats:
            if cat in self.checkbox_cats:
                file_data["{}_{}".format(input_file, cat)] = tk.IntVar()
                file_data[cat] = ttk.Checkbutton(file_data["frame"], text=self.cat_labels[cat],
                                                variable=file_data["{}_{}".format(input_file, cat)])
                self.pre_fill_entry(cat, input_file, file_data)
                file_data[cat].grid(row=row_number, column=0, columnspan=2, sticky=tk.W, ipady=2)
            else:
                ttk.Label(file_data["frame"], text=self.cat_labels[cat]).grid(row=row_number, column=0, sticky=tk.W)
                file_data[cat] = ttk.Entry(file_data["frame"])
                self.pre_fill_entry(cat, input_file, file_data)
                file_data[cat].grid(row=row_number, column=1)
                
            row_number += 1
        return file_data

    def pre_fill_entry(self, cat, input_file, file_data):
        """See if the input is in our config list, and insert preset values if so."""
        if input_file not in self.validator_config.config:
            return
        if cat not in self.validator_config.config[input_file]:
            return
        if cat in self.checkbox_cats:
            if self.validator_config.config[input_file][cat]:
                file_data["{}_{}".format(input_file, cat)].set(value=1)
        else:
            file_data[cat].insert(0, self.validator_config.config[input_file][cat])

    def basic_field_validation(self, input_file, field_name, field_to_check):
        if not field_to_check:
            return
        if len(field_to_check) < 3 or len(field_to_check) > 4:
            self.warnings.append("{}\n{} field {} is invalid length".format(input_file, field_to_check, field_name))
            return
        field = field_to_check[:3]
        field_int = ''
        if field.lower() != 'ldr':
            try:
                field_int = int(field)
            except ValueError:
                self.warnings.append("{}\n{} field {} is invalid field".format(input_file, field_to_check, field_name))
                return
        if field_int > 10 and len(field_to_check) == 3 and field_int != 35:
            self.warnings.append("{}\n{} field {} should have subfield".format(input_file, field_to_check, field_name))
        if len(field_to_check) == 4:
            subfield = field_to_check[3:]
            if not re.search(r"\w", subfield):
                self.warnings.append("{}\n{} field {} has invalid subfield".format(input_file, field_to_check,
                                                                                   field_name))

    def ok_clicked(self):
        """Record user choices to the config file."""
        for input_file in self.all_input_files:
            self.ok_clicked_get_file_data(input_file)

        if self.warnings:
            msg = ''
            response = tkinter.messagebox.showerror(title='ERROR', message="\n\n".join(self.warnings))
            self.cancelled()
            self.create_main_window()
        else:
            self.validator_config.write_validator_config_file()
            self.cancelled()

    def ok_clicked_get_file_data(self, input_file):
        possible_fields = ['{}_{}'.format(input_file, 'header'), '{}_583'.format(input_file), 'oclc', 'bib_id',
                           'holdings_id',
                           '{}_863'.format(input_file), '{}_866'.format(input_file), 'holdings_0', 'holdings_1',
                           'holdings_2', 'issn', 'title',  'institution', 'oclc_symbol', 'location', ]
        fields_to_validate = {'oclc', 'holdings_id', 'bib_id', 'holdings_1', 'holdings_2'}
        file_data = {}
        self.validator_config.config[input_file] = {}

        for possible_field in possible_fields:
            try:
                file_data[possible_field] = self.fields[input_file][possible_field].get()
            except KeyError:
                pass

        for possible_field in possible_fields:
            if possible_field not in file_data or not file_data[possible_field]:
                continue
            if input_file.endswith('.mrk') and possible_field in fields_to_validate:
                self.basic_field_validation(input_file, possible_field, file_data[possible_field])
            if '863' in possible_field:
                cat_name = '{}_863'.format(input_file)
                self.validator_config.config[input_file]['863'] = str(file_data[cat_name])
            elif '866' in possible_field:
                cat_name = '{}_866'.format(input_file)
                self.validator_config.config[input_file]['866'] = str(file_data[cat_name])
            elif '583' in possible_field:
                cat_name = '{}_583'.format(input_file)
                self.validator_config.config[input_file]['583'] = str(file_data[cat_name])
            elif 'header' in possible_field:
                cat_name = '{}_{}'.format(input_file, 'header')
                self.validator_config.config[input_file]['header'] = str(file_data[cat_name])
            else:
                self.validator_config.config[input_file][possible_field] = file_data[possible_field]

    def reset_fields(self):
        """
        This works by resetting the config file for all files, closing the window, then starting over.
        """
        for input_file in self.all_input_files:
            if input_file in self.validator_config.config.keys():
                del self.validator_config.config[input_file]

        self.validator_config.write_validator_config_file()
        self.validator_config.read_validator_config_file()
        self.cancelled()
        self.create_main_window()        

    def cancelled(self):
        """Close without making any changes."""
        self.destroy()

    def create_main_window(self):
        """Start over with a new window."""
        self.__init__(self.all_input_files)


def test_app():
    print('runnin')
    import os
    i = InputFieldsChooser(os.listdir('input'))


if __name__ == "__main__":
    test_app()
